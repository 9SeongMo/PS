
# 리눅스 디바이스 드라이버
-----------------------------------------------
- ## g-camp 관련 강의를 보면서 필기내용 정리한것입니다 문제시 알려주시면 바로 삭제하겠습니다


- ## 리눅스 디바이스 드라이버란

	- 커널과 주변 장치간 데이터를 전달하는 프로그램
	
	-  종류
		+ 일반적으로 문자,브록,네트워크 디바이스 드라이버로 분류하며, /dev에 나타난다, 네트워크는 여기아님
		+ ls -l /dev 해보면 쭉 리스트나온다잉

		+ 문자 디바이스 드라이버
			+ 임이의 길이를 갖는 문자열을 다루는 디바이스 드라이버
			+ Character 단위, 즉 바이트단위로 입출력을 하는 Device

		+ 블럭 디바이스 드라이버
			+ 일정한 크기의 버퍼(커널 내부의 버퍼)를 통해 데이터를 처리하는 디바이스 드라이버
			+ Block 단위로 입출력을 하는 Device, Block은 File System의 섹터를 의미

		+ 네트워크 디바이스 드라이버
			+ 네트워크 층과 연결되어 있음(루프백 장치, 랜카드 등)
			+ 응용프로그램에서 직접적인 처리가 불가능하다
			+ 커널 내부에 있는 네트워크 프로토콜 스택과 연동해서 사용한다

	- 로더블(Loadable)특성
		+ 대부분의 리눅스 디바이스 드라이버는 커널 모듈로서, 필요할때 로드하고 더이상 필요하지않을때 언로드 할수있다 -> 시스템자원 효율적 이용가능
	

- ## 리눅스 시스템 전체구조

	- 디바이스 드라이버는 디바이스를 추상화하여 사용자 애플리케이션에서 시스템호출 인터페이스를 통해 디바이스드라이버에 접근할 수 있도록 해준다
	- 이를 위해 리눅스는 가상파일시스템(VFS) layer를 제공
	- ex) open(); read();
	![제작과정](https://user-images.githubusercontent.com/68523963/104547441-e482c280-5671-11eb-992f-9e26b486890a.PNG)



- ## 리눅스 디바이스 드라이버 개요 

	- 리눅스에서는 모든것을 파일로 관리한다
		+ 고로 Board에 연결된 장치도 그 장치를 표현하는 하나의 장치파일(Device file)로 관리된다
		+ 그 장치파일을 사용 할 수 있게 해주는것이 장치드라이버이고 디바이스 드라이버는 디바이스를 file로 보고 관리한다

	- Device Driver 작성과 사용 
		+ Device Drive는 정해진 function으로 장치를 제어하도록 작성된다[ ex) open(); read();]
		+ 응용프로그램에서는 정해진 function으로 디바이스 드라이버의 function을 사용함으로써 장치를 사용할수있게된다
	
	- 기본적인 특징중 하나가 뭐냐 바로 장치다루는것을 추상화한다는 것임
		+ 모든 하드웨어 장치들은 보통파일처럼보이며 파일을 다루는데 쓰이는 표준 시스템콜과 똑같은 함수를 이용하여 열고,닫고,읽고,쓸수있다
	
	- 똑같은 디바이스 드라이버로 제어되는 모든장치는 똑같은 메이저 장치번호를 갖는다 [ ex) tty ] 마이너 장치번호는 다른장치나 컨트롤러를 구분하는데 사용[ ex) tty1,tty2 ]


- ## khadas vim3 linux source 사용
	- git clone https://github.com/khadas/linux/ -b khadas-vims-4.9.y


- ## Character Device Driver

	- 정의 및 특징
		+ 문자디바이스는 하나의 파일처럼 사용할 수 있는것(버튼, G-sensor, joystic, RTC)을 말하고 이러한 파일 접근에 필요한 open close read write등의 시스템 호출을 구현
		+ 디바이스에서 자료에 순차적으로 접근 가능한 커널 코드
		+ 임의의 길이를 갖는 문자열을 다루고 응용프로그램에서 직접호출되는 버퍼없는 드라이버
		+ 응용프로그램은 open(),close(),read() 와 같은 파일처리용 함수를 이용하여 디바이스파일을 일반 파일처럼 다뤄 하드웨어를 제어할 수 있다
		+ 많이사용되고 구조가 매우 간단
	- 기능
		+ 초기화 루틴이 꼭 필요하다
		+ /dev 노드에 있는 파일을 사용자 어플리케이션이 시스템호출과 대응하는 명령으로 사용가능
		+ 타이머, 인터럽트 처리

	- Character Device Driver 주요 자료구조
		+ 디바이스별 구조체 : 드라이버 동작을 위한 정보 저장소
		+ struct cdev :
		+ struct file_operations :
		+ struct file :
		+ struct platform_device, struct platform_driver :


- ## 모듈 디바이스 드라이버 제작과정
	![제작과정](https://user-images.githubusercontent.com/68523963/104547451-e9477680-5671-11eb-8ca6-c49ed52585da.PNG)

	<br/>

- ## Linux Device Driver 작성단계

	- 디바이스 드라이버 초기화 인터페이스 구현(주번호 할당 및 디바이스 드라이버 루틴등록)
		+ ``` register_chrdev(240,"gpio_dev", &chr_fops) ```

	- 디바이스 드라이버 커널 인터페이스 구현
		+ entry point fucntion, file_operations

	- 디바이스 드라이버 하드웨어 인터페이스 구현 레지스터 접근

	- 장치 파일 생성
		+ mknod

	- 응용프로그램 작성

	- 커널 컴파일 및 리부팅 or 모듈설치


- ## Linux Device Driver 상세설명

	- 초기화 인터페이스
		+ Init()함수 (Init_module() 함수), 모듈에는 init 함수와 exit 함수는 꼭 있어야한다
		+ ``` register_chrdev() register_blkdev() ```

	- 시스템 인터페이스 (커널 인터페이스)
		+ 문자/블럭 드라이버의 경우 file_operations 구조체를 이용
		+ 네트워크 드라이버의 경우 open,close,transmit,recieve 같은 함수를 사용

	- 하드웨어 인터페이스
		+ Memory Mapped I/O 레지스터 주소값을 사용
		+ 특정 Port를 사용한다 in(),out()

	- 장치파일
	 
	- 일반 파일을 제어하듯 디바이스파일에 입출력을 시도하고 커널내 해당 디바이스 파일에 연결된 디바이스 드라이버의 서비스루틴이 호출되어 처리한다(제어권은 커널로)

	- 서비스루틴에서의 모든 처리가 완료되면 제어권은 다시 응용프로그램으로 넘겨진다 -> 이렇게 하기위해서 모듈이라는 형식을 빌려만듬


- ## 모듈
	- 커널 라이브러리를 .ko 형태로 만들어 시스템 콜을 통해 커널에 적재하고 해당 객체를 커널에 동적으로 링크하여 사용한다
	- 이를 위해 커널에 심볼테이블 기능이 추가됨 
		+ /proc/kallsyms


- ## 구동과정
	- 디바이스 드라이버 등록
		+ 가장먼저 디바이스 드라이버를 리눅스 커널에 등록시키는것 해줘야지, 결국 디바이스제어는 커널내 드라이버가 하는것이니까
		+ Kernel Module 형태로 컴파일한뒤(.ko) 파일을 insmod 명령어로 커널 메모리영역내에 추가하는 형태로 등록하거나 커널소스내에 포함시켜 같이 컴파일 시키는 방법이 있다
		+ 초기에는 모듈형태로 개발하고 개발종료시 커널내에 포함시켜 컴파일하거나 커널모듈파일이 부팅시 자동적으로 삽입되도록 부팅스크립트 파일들에 기입해 놓는 방식으로 개발이 된다
 
	- 디바이스 파일 생성
		+ 디바이스파일은 C언어에서 포인터같은 역할, 유저 어플리케이션이 디바이스를 제어하기위해 디바이스파일에 쓰고 읽기를 한다
		+ 이런 디바이스파일은 일명 디바이스노드라고 불리며 mknod명령을 통해 생성
		+ ``` mknod /dev/gpioled c 200 0 ```

	- 디바이스 파일 접근 
		+ 디바이스파일은 스스로 독립적으로 실행될수없지 그래서 사용자 파일이 시스템콜(open) 함수를 이용해 실행하라고 알려줘야함
		+ open() 함수를 서비스해주기 위해 리눅스 커널이 해당파일로 접근하게되겠지 근데 이 파일이 디바이스 파일임을 알게되면 디바이스를 제어하게다고 커널에게 등록한 디바이스 드라이버들을 검색하게된다
		+ 메이져넘버 검색

	- 디바이스 드라이버 연동
		+ 검색되어 실행시켰으면 이제 유저 어플리케이션과 연동됨, 유저 어플리케이션이 파일제어함수를 통해 제어요청을 하면 디바이스드라이버가 직접 디바이스를 제어함


- ## 리눅스 디바이스 드라이버 - Read/Write 함수
	- copy_from_user() , copy_to_user()
		+ 함수의 주체는 디바이스 드라이버
		+ 유저 어플리케이션의 버퍼와 디바이스 드라이버의 버퍼에 서로 읽고 쓰고 난리치기위해
		+ 자세한거는 검색

- ## kernel header
	+ 모듈이 컴파일 되기 위해서는 커널 헤더들이 있어야함
	+ 해당 커널 버전에 맞는 헤더파일이 있어야함, 커널 버전만 맞으면 다른 보드라도 컴파일이 가능함
	+ 근데 카다스 보드는 패키지 업데이트 업그레이드하면 따로 해줄필요없음
	+ ``` sudo apt-get install linux-headers-`uname-r` ```

- ## 출처
	- https://www.g.camp/1949 강의 필기

	<br/><br/><br/>